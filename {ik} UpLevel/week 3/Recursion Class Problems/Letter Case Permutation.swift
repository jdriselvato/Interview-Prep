// Letter Case Permutation

/*

Given a string, return all strings that can be generated by changing case of one or more letters in it.

Example One

{
"s": "a1z"
}
Output:

["A1Z", "A1z", "a1Z", "a1z"]
Example Two

{
"s": "123"
}
Output:

["123"]
Notes

Return strings in any order.

Constraints:

Input string may contain only: 'a'..'z', 'A'..'Z', '0'..'9'
1 <= length of the string <= 12
*/

// Questions to ask:
// 1. What is the number of blocks? n; because we are changing the case of n number of letters in a string
// 2. What are the choices? 2; because either uppercase or lower case, 3 if you count skipping over numbers
// 3. Will this have a for loop? maybe to cycle through each character.


func letter_case_permutations(s: String) -> [String] {
	var slate: String = ""
	var result = [String]()
    
    helper(Array(s), index: 0, slate: &slate, result: &result)

    return result
}

func helper(_ c: [Character], index: Int, slate: inout String, result: inout [String]) {

	// base case
	if index == c.count { // if c == slate count then we've reached block size
		result.append(String(slate))
		return
	}

	// two choices:

	let currentChar = c[index]

	if currentChar.isNumber {
		slate.append(currentChar)
		helper(c, index: index+1, slate: &slate, result: &result)
		slate.removeLast()

	} else {

	// 	// uppcase
		slate.append(Character(currentChar.uppercased()))
		helper(c, index: index+1, slate: &slate, result: &result)
		slate.removeLast()

	// 	// lowercase
		slate.append(Character(currentChar.lowercased()))
		helper(c, index: index+1, slate: &slate, result: &result)
		slate.removeLast()
	}

}

print(letter_case_permutations(s: "1eF"))

// Hang ups:

// Going down the for in loop route completely messed me up. passing an index makes sense, but I don't know how i would have thought to do that here 